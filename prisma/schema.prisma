// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id             String       @id @default(uuid())
  username       String       @unique
  email          String?      @unique
  passwordHash   String?
  isActive       Boolean      @default(true)
  isVerified     Boolean      @default(false)
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  deletedAt      DateTime?

  profile        Profile?
  photos         UserPhoto[]
  interests      UserInterest[]
  socialAccounts SocialAccount[]
  swipesMade     Swipe[]      @relation("swipes_made")
  swipesReceived Swipe[]      @relation("swipes_received")
  matchesA       Match[]      @relation("userA")
  matchesB       Match[]      @relation("userB")
  threadsA       ChatThread[] @relation("participantA")
  threadsB       ChatThread[] @relation("participantB")
  messages       Message[]
  notifications  Notification[]
  agreements     AgreementAcceptance[]
  refreshTokens  RefreshToken[]
}

model Profile {
  id             String     @id @default(uuid())
  user           User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId         String     @unique
  avatarPhotoId  String?    @unique
  gender         String?
  bio            String?
  city           String?
  country        String?
  lat            Float?
  lon            Float?
  university     String?
  degree         String?
  major          String?
  avatarPhoto    UserPhoto? @relation("ProfileAvatarPhoto", fields: [avatarPhotoId], references: [id])

  @@index([lat, lon])
  @@index([gender])
}

model UserPhoto {
  id        String   @id @default(uuid())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  s3Key     String
  ordering  Int      @default(0)
  createdAt DateTime @default(now())
  profile   Profile? @relation("ProfileAvatarPhoto")

  @@unique([userId, ordering])
}

model Interest {
  id    String @id @default(uuid())
  name  String @unique
  users UserInterest[]
}

model UserInterest {
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId     String
  interest   Interest @relation(fields: [interestId], references: [id], onDelete: Cascade)
  interestId String

  @@id([userId, interestId])
}

model SocialAccount {
  id             String   @id @default(uuid())
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId         String
  provider       String
  providerUserId String
  accessToken    String?
  createdAt      DateTime @default(now())

  @@unique([provider, providerUserId])
}

model Swipe {
  id        String   @id @default(uuid())
  swiper    User     @relation("swipes_made", fields: [swiperId], references: [id], onDelete: Cascade)
  swiperId  String
  swiped    User     @relation("swipes_received", fields: [swipedId], references: [id], onDelete: Cascade)
  swipedId  String
  liked     Boolean
  createdAt DateTime @default(now())

  @@unique([swiperId, swipedId])
}

model Match {
  id        String   @id @default(uuid())
  userA     User     @relation("userA", fields: [userAId], references: [id], onDelete: Cascade)
  userAId   String
  userB     User     @relation("userB", fields: [userBId], references: [id], onDelete: Cascade)
  userBId   String
  createdAt DateTime @default(now())

  chatThread ChatThread?

  @@unique([userAId, userBId])
}

model ChatThread {
  id             String   @id @default(uuid())
  match          Match?   @relation(fields: [matchId], references: [id], onDelete: Cascade)
  matchId        String?  @unique
  participantA   User     @relation("participantA", fields: [participantAId], references: [id])
  participantAId String
  participantB   User     @relation("participantB", fields: [participantBId], references: [id])
  participantBId String
  lastMessage    String?
  lastMessageAt  DateTime?
  unreadCountA   Int      @default(0)
  unreadCountB   Int      @default(0)
  createdAt      DateTime @default(now())

  messages Message[]
}

model Message {
  id         String      @id @default(uuid())
  thread     ChatThread  @relation(fields: [threadId], references: [id], onDelete: Cascade)
  threadId   String
  sender     User        @relation(fields: [senderId], references: [id])
  senderId   String
  content    String
  metadata   Json?
  createdAt  DateTime    @default(now())
  deliveredAt DateTime?
  readAt      DateTime?
}

model Notification {
  id        String   @id @default(uuid())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  type      NotificationType
  payload   Json
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())
}

enum NotificationType {
  CHAT
  MATCH
  SYSTEM
}

model RefreshToken {
  id         String   @id @default(uuid())
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId     String
  tokenHash  String   @unique
  ip         String?
  userAgent  String?
  revoked    Boolean  @default(false)
  createdAt  DateTime @default(now())
  expiresAt  DateTime
}

model Agreement {
  id        String   @id @default(uuid())
  version   String   @unique
  content   String
  createdAt DateTime @default(now())
  acceptances AgreementAcceptance[]
}

model AgreementAcceptance {
  id               String   @id @default(uuid())
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId           String
  agreement        Agreement @relation(fields: [agreementId], references: [id], onDelete: Cascade)
  agreementId      String
  acceptedAt       DateTime @default(now())
}